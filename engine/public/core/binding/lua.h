#pragma once

#include "core/api/engine_api.h"
#include "core/component/components.h"
#include "core/project_config.h"

// NOTE: THIS LUA BINDING SYSTEM WAS GENERATED BY AI
// IT IS VERY LIKELY TO CONTAIN BUGS, AND CERTAIN FEATURES MAY NOT WORK PROPERLY
namespace binding {

template<typename T>
struct userdata_wrapper {
    T* ptr;
};

// Get metatable name for type
template<typename T>
const char* metatable_name() {
    static std::string name = std::string("mt_") + typeid(T).name();
    return name.c_str();
}

// Property info structure
struct property_info {
    std::function<int(lua_State*, void*)> getter;
    std::function<int(lua_State*, void*)> setter;
};

// Global registry for properties
template<typename T>
std::unordered_map<std::string, property_info>& get_properties() {
    static std::unordered_map<std::string, property_info> properties;
    return properties;
}

// Global registry for methods  
template<typename T>
std::unordered_map<std::string, lua_CFunction>& get_methods() {
    static std::unordered_map<std::string, lua_CFunction> methods;
    return methods;
}

// Push a pointer as userdata
template<typename T>
void push_userdata(lua_State* L, T* ptr) {
    auto* wrapper = (userdata_wrapper<T>*)lua_newuserdata(L, sizeof(userdata_wrapper<T>));
    wrapper->ptr = ptr;
    luaL_getmetatable(L, metatable_name<T>());
    lua_setmetatable(L, -2);
}

// Get pointer from userdata
template<typename T>
T* check_userdata(lua_State* L, int index) {
    auto* wrapper = (userdata_wrapper<T>*)luaL_checkudata(L, index, metatable_name<T>());
    return wrapper->ptr;
}

// Generic __index metamethod
template<typename T>
int index_metamethod(lua_State* L) {
    T* obj = check_userdata<T>(L, 1);
    const char* key = luaL_checkstring(L, 2);
    
    auto& properties = get_properties<T>();
    auto& methods = get_methods<T>();
    
    // Check properties first
    auto prop_it = properties.find(key);
    if (prop_it != properties.end() && prop_it->second.getter) {
        return prop_it->second.getter(L, obj);
    }
    
    // Check methods
    auto method_it = methods.find(key);
    if (method_it != methods.end()) {
        lua_pushcfunction(L, method_it->second);
        return 1;
    }
    
    lua_pushnil(L);
    return 1;
}

// Generic __newindex metamethod
template<typename T>
int newindex_metamethod(lua_State* L) {
    T* obj = check_userdata<T>(L, 1);
    const char* key = luaL_checkstring(L, 2);
    
    auto& properties = get_properties<T>();
    
    // Check properties
    auto prop_it = properties.find(key);
    if (prop_it != properties.end() && prop_it->second.setter) {
        return prop_it->second.setter(L, obj);
    }
    
    return luaL_error(L, "Cannot set property '%s'", key);
}

// Create metatable for type
template<typename T>
void create_metatable(lua_State* L) {
    luaL_newmetatable(L, metatable_name<T>());
    
    lua_pushcfunction(L, index_metamethod<T>);
    lua_setfield(L, -2, "__index");
    
    lua_pushcfunction(L, newindex_metamethod<T>);
    lua_setfield(L, -2, "__newindex");
    
    lua_pop(L, 1);
}

// Add property to type
template<typename T, typename PropType>
void add_property(const std::string& name, PropType T::*member) {
    auto& properties = get_properties<T>();
    
    property_info info;
    
    // Create getter
    info.getter = [member](lua_State* L, void* obj_ptr) -> int {
        T* obj = static_cast<T*>(obj_ptr);
        auto& prop = obj->*member;
        
        if constexpr (std::is_same_v<PropType, int> || std::is_same_v<PropType, long> || std::is_same_v<PropType, uint32_t>) {
            lua_pushinteger(L, static_cast<lua_Integer>(prop));
        } else if constexpr (std::is_same_v<PropType, float> || std::is_same_v<PropType, double>) {
            lua_pushnumber(L, static_cast<lua_Number>(prop));
        } else if constexpr (std::is_same_v<PropType, bool>) {
            lua_pushboolean(L, prop);
        } else if constexpr (std::is_same_v<PropType, std::string>) {
            lua_pushstring(L, prop.c_str());
        } else {
            // For complex types like glm::vec2, glm::vec4, etc.
            push_userdata(L, &prop);
        }
        return 1;
    };
    
    // Create setter
    info.setter = [member](lua_State* L, void* obj_ptr) -> int {
        T* obj = static_cast<T*>(obj_ptr);
        
        if constexpr (std::is_same_v<PropType, int> || std::is_same_v<PropType, long> || std::is_same_v<PropType, uint32_t>) {
            obj->*member = static_cast<PropType>(luaL_checkinteger(L, 3));
        } else if constexpr (std::is_same_v<PropType, float> || std::is_same_v<PropType, double>) {
            obj->*member = static_cast<PropType>(luaL_checknumber(L, 3));
        } else if constexpr (std::is_same_v<PropType, bool>) {
            obj->*member = lua_toboolean(L, 3);
        } else if constexpr (std::is_same_v<PropType, std::string>) {
            obj->*member = luaL_checkstring(L, 3);
        } else {
            // For complex types, get from userdata
            PropType* src = check_userdata<PropType>(L, 3);
            obj->*member = *src;
        }
        return 0;
    };
    
    properties[name] = info;
}

// Add method to type
template<typename T>
void add_method(const std::string& name, lua_CFunction func) {
    auto& methods = get_methods<T>();
    methods[name] = func;
}


} // namespace binding




void push_sdl_event_to_lua(lua_State* L, const SDL_Event& event);

// =======================================================
// Generate Lua bindings for an entity
// =======================================================
void generate_bindings(lua_State* L);

void push_entity_to_lua(lua_State* L, flecs::entity e);